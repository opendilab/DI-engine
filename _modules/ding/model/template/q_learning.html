

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ding.model.template.q_learning &mdash; DI-engine 0.1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href="../../../../_static/css/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> DI-engine
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quick_start/index.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../key_concept/index.html">Key Concept</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro_rl/index.html">Introduction to RL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../hands_on/index.html">RL Algorithm Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../env_tutorial/index.html">RL Environments Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../distributed/index.html">Distributed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../best_practice/index.html">Best Practice</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_doc/index.html">API Doc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../feature/index.html">Feature</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/index.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_dev/index.html">Tutorial-Developer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../architecture/index.html">Architecture Design</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">DI-engine</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>ding.model.template.q_learning</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ding.model.template.q_learning</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>

<span class="kn">from</span> <span class="nn">ding.torch_utils</span> <span class="kn">import</span> <span class="n">get_lstm</span>
<span class="kn">from</span> <span class="nn">ding.utils</span> <span class="kn">import</span> <span class="n">MODEL_REGISTRY</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">,</span> <span class="n">squeeze</span>
<span class="kn">from</span> <span class="nn">..common</span> <span class="kn">import</span> <span class="n">FCEncoder</span><span class="p">,</span> <span class="n">ConvEncoder</span><span class="p">,</span> <span class="n">DiscreteHead</span><span class="p">,</span> <span class="n">DuelingHead</span><span class="p">,</span> <span class="n">MultiHead</span><span class="p">,</span> <span class="n">RainbowHead</span><span class="p">,</span> \
    <span class="n">QuantileHead</span><span class="p">,</span> <span class="n">QRDQNHead</span><span class="p">,</span> <span class="n">DistributionHead</span>
<span class="kn">from</span> <span class="nn">ding.torch_utils.network.gtrxl</span> <span class="kn">import</span> <span class="n">GTrXL</span>


<div class="viewcode-block" id="DQN"><a class="viewcode-back" href="../../../../hands_on/dqn_zh.html#ding.model.template.q_learning.DQN">[docs]</a><span class="nd">@MODEL_REGISTRY</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;dqn&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">DQN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>

<div class="viewcode-block" id="DQN.__init__"><a class="viewcode-back" href="../../../../hands_on/dqfd.html#ding.model.template.q_learning.DQN.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">obs_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
            <span class="n">action_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
            <span class="n">encoder_hidden_size_list</span><span class="p">:</span> <span class="n">SequenceType</span> <span class="o">=</span> <span class="p">[</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span>
            <span class="n">dueling</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">head_hidden_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">head_layer_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">activation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(),</span>
            <span class="n">norm_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Init the DQN (encoder + head) Model according to input arguments.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - obs_shape (:obj:`Union[int, SequenceType]`): Observation space shape, such as 8 or [4, 84, 84].</span>
<span class="sd">            - action_shape (:obj:`Union[int, SequenceType]`): Action space shape, such as 6 or [2, 3, 3].</span>
<span class="sd">            - encoder_hidden_size_list (:obj:`SequenceType`): Collection of ``hidden_size`` to pass to ``Encoder``, \</span>
<span class="sd">                the last element must match ``head_hidden_size``.</span>
<span class="sd">            - dueling (:obj:`dueling`): Whether choose ``DuelingHead`` or ``DiscreteHead(default)``.</span>
<span class="sd">            - head_hidden_size (:obj:`Optional[int]`): The ``hidden_size`` of head network.</span>
<span class="sd">            - head_layer_num (:obj:`int`): The number of layers used in the head network to compute Q value output</span>
<span class="sd">            - activation (:obj:`Optional[nn.Module]`): The type of activation function in networks \</span>
<span class="sd">                if ``None`` then default set it to ``nn.ReLU()``</span>
<span class="sd">            - norm_type (:obj:`Optional[str]`): The type of normalization in networks, see \</span>
<span class="sd">                ``ding.torch_utils.fc_block`` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DQN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># For compatibility: 1, (1, ), [4, 32, 32]</span>
        <span class="n">obs_shape</span><span class="p">,</span> <span class="n">action_shape</span> <span class="o">=</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">),</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">action_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">head_hidden_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head_hidden_size</span> <span class="o">=</span> <span class="n">encoder_hidden_size_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># FC Encoder</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">FCEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="c1"># Conv Encoder</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ConvEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;not support obs_shape for pre-defined encoder: </span><span class="si">{}</span><span class="s2">, please customize your own DQN&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Head Type</span>
        <span class="k">if</span> <span class="n">dueling</span><span class="p">:</span>
            <span class="n">head_cls</span> <span class="o">=</span> <span class="n">DuelingHead</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head_cls</span> <span class="o">=</span> <span class="n">DiscreteHead</span>
        <span class="n">multi_head</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">action_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multi_head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">MultiHead</span><span class="p">(</span>
                <span class="n">head_cls</span><span class="p">,</span>
                <span class="n">head_hidden_size</span><span class="p">,</span>
                <span class="n">action_shape</span><span class="p">,</span>
                <span class="n">layer_num</span><span class="o">=</span><span class="n">head_layer_num</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head_cls</span><span class="p">(</span>
                <span class="n">head_hidden_size</span><span class="p">,</span> <span class="n">action_shape</span><span class="p">,</span> <span class="n">head_layer_num</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="DQN.forward"><a class="viewcode-back" href="../../../../hands_on/dqn_zh.html#ding.model.template.q_learning.DQN.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            DQN forward computation graph, input observation tensor to predict q_value.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - x (:obj:`torch.Tensor`): Observation inputs</span>
<span class="sd">        Returns:</span>
<span class="sd">            - outputs (:obj:`Dict`): DQN forward outputs, such as q_value.</span>
<span class="sd">        ReturnsKeys:</span>
<span class="sd">            - logit (:obj:`torch.Tensor`): Discrete Q-value output of each action dimension.</span>
<span class="sd">        Shapes:</span>
<span class="sd">            - x (:obj:`torch.Tensor`): :math:`(B, N)`, where B is batch size and N is ``obs_shape``</span>
<span class="sd">            - logit (:obj:`torch.FloatTensor`): :math:`(B, M)`, where B is batch size and M is ``action_shape``</span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; model = DQN(32, 6)  # arguments: &#39;obs_shape&#39; and &#39;action_shape&#39;</span>
<span class="sd">            &gt;&gt;&gt; inputs = torch.randn(4, 32)</span>
<span class="sd">            &gt;&gt;&gt; outputs = model(inputs)</span>
<span class="sd">            &gt;&gt;&gt; assert isinstance(outputs, dict) and outputs[&#39;logit&#39;].shape == torch.Size([4, 6])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div></div>


<div class="viewcode-block" id="C51DQN"><a class="viewcode-back" href="../../../../hands_on/c51_qrdqn_iqn.html#ding.model.template.q_learning.C51DQN">[docs]</a><span class="nd">@MODEL_REGISTRY</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;c51dqn&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">C51DQN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obs_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
        <span class="n">action_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
        <span class="n">encoder_hidden_size_list</span><span class="p">:</span> <span class="n">SequenceType</span> <span class="o">=</span> <span class="p">[</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span>
        <span class="n">head_hidden_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">head_layer_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">activation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(),</span>
        <span class="n">norm_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">v_min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">v_max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">n_atom</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">51</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Init the C51 Model according to input arguments.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - obs_shape (:obj:`Union[int, SequenceType]`): Observation&#39;s space.</span>
<span class="sd">            - action_shape (:obj:`Union[int, SequenceType]`): Action&#39;s space.</span>
<span class="sd">            - encoder_hidden_size_list (:obj:`SequenceType`): Collection of ``hidden_size`` to pass to ``Encoder``</span>
<span class="sd">            - head_hidden_size (:obj:`Optional[int]`): The ``hidden_size`` to pass to ``Head``.</span>
<span class="sd">            - head_layer_num (:obj:`int`): The num of layers used in the network to compute Q value output</span>
<span class="sd">            - activation (:obj:`Optional[nn.Module]`):</span>
<span class="sd">                The type of activation function to use in ``MLP`` the after ``layer_fn``,</span>
<span class="sd">                if ``None`` then default set to ``nn.ReLU()``</span>
<span class="sd">            - norm_type (:obj:`Optional[str]`):</span>
<span class="sd">                The type of normalization to use, see ``ding.torch_utils.fc_block`` for more details`</span>
<span class="sd">            - n_atom (:obj:`Optional[int]`): Number of atoms in the prediction distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">C51DQN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># For compatibility: 1, (1, ), [4, 32, 32]</span>
        <span class="n">obs_shape</span><span class="p">,</span> <span class="n">action_shape</span> <span class="o">=</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">),</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">action_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">head_hidden_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head_hidden_size</span> <span class="o">=</span> <span class="n">encoder_hidden_size_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># FC Encoder</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">FCEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="c1"># Conv Encoder</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ConvEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;not support obs_shape for pre-defined encoder: </span><span class="si">{}</span><span class="s2">, please customize your own C51DQN&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Head Type</span>
        <span class="n">multi_head</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">action_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multi_head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">MultiHead</span><span class="p">(</span>
                <span class="n">DistributionHead</span><span class="p">,</span>
                <span class="n">head_hidden_size</span><span class="p">,</span>
                <span class="n">action_shape</span><span class="p">,</span>
                <span class="n">layer_num</span><span class="o">=</span><span class="n">head_layer_num</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">,</span>
                <span class="n">n_atom</span><span class="o">=</span><span class="n">n_atom</span><span class="p">,</span>
                <span class="n">v_min</span><span class="o">=</span><span class="n">v_min</span><span class="p">,</span>
                <span class="n">v_max</span><span class="o">=</span><span class="n">v_max</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">DistributionHead</span><span class="p">(</span>
                <span class="n">head_hidden_size</span><span class="p">,</span>
                <span class="n">action_shape</span><span class="p">,</span>
                <span class="n">head_layer_num</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">,</span>
                <span class="n">n_atom</span><span class="o">=</span><span class="n">n_atom</span><span class="p">,</span>
                <span class="n">v_min</span><span class="o">=</span><span class="n">v_min</span><span class="p">,</span>
                <span class="n">v_max</span><span class="o">=</span><span class="n">v_max</span><span class="p">,</span>
            <span class="p">)</span>

<div class="viewcode-block" id="C51DQN.forward"><a class="viewcode-back" href="../../../../hands_on/c51_qrdqn_iqn.html#ding.model.template.q_learning.C51DQN.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Use observation tensor to predict C51DQN&#39;s output.</span>
<span class="sd">            Parameter updates with C51DQN&#39;s MLPs forward setup.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - x (:obj:`torch.Tensor`):</span>
<span class="sd">                The encoded embedding tensor w/ ``(B, N=head_hidden_size)``.</span>
<span class="sd">        Returns:</span>
<span class="sd">            - outputs (:obj:`Dict`):</span>
<span class="sd">                Run with encoder and head. Return the result prediction dictionary.</span>

<span class="sd">        ReturnsKeys:</span>
<span class="sd">            - logit (:obj:`torch.Tensor`): Logit tensor with same size as input ``x``.</span>
<span class="sd">            - distribution (:obj:`torch.Tensor`): Distribution tensor of size ``(B, N, n_atom)``</span>
<span class="sd">        Shapes:</span>
<span class="sd">            - x (:obj:`torch.Tensor`): :math:`(B, N)`, where B is batch size and N is head_hidden_size.</span>
<span class="sd">            - logit (:obj:`torch.FloatTensor`): :math:`(B, M)`, where M is action_shape.</span>
<span class="sd">            - distribution(:obj:`torch.FloatTensor`): :math:`(B, M, P)`, where P is n_atom.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; model = C51DQN(128, 64)  # arguments: &#39;obs_shape&#39; and &#39;action_shape&#39;</span>
<span class="sd">            &gt;&gt;&gt; inputs = torch.randn(4, 128)</span>
<span class="sd">            &gt;&gt;&gt; outputs = model(inputs)</span>
<span class="sd">            &gt;&gt;&gt; assert isinstance(outputs, dict)</span>
<span class="sd">            &gt;&gt;&gt; # default head_hidden_size: int = 64,</span>
<span class="sd">            &gt;&gt;&gt; assert outputs[&#39;logit&#39;].shape == torch.Size([4, 64])</span>
<span class="sd">            &gt;&gt;&gt; # default n_atom: int = 51</span>
<span class="sd">            &gt;&gt;&gt; assert outputs[&#39;distribution&#39;].shape == torch.Size([4, 64, 51])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div></div>


<div class="viewcode-block" id="QRDQN"><a class="viewcode-back" href="../../../../hands_on/c51_qrdqn_iqn.html#ding.model.template.q_learning.QRDQN">[docs]</a><span class="nd">@MODEL_REGISTRY</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;qrdqn&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">QRDQN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">obs_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
            <span class="n">action_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
            <span class="n">encoder_hidden_size_list</span><span class="p">:</span> <span class="n">SequenceType</span> <span class="o">=</span> <span class="p">[</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span>
            <span class="n">head_hidden_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">head_layer_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">num_quantiles</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
            <span class="n">activation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(),</span>
            <span class="n">norm_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Init the QRDQN Model according to input arguments.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - obs_shape (:obj:`Union[int, SequenceType]`): Observation&#39;s space.</span>
<span class="sd">            - action_shape (:obj:`Union[int, SequenceType]`): Action&#39;s space.</span>
<span class="sd">            - encoder_hidden_size_list (:obj:`SequenceType`): Collection of ``hidden_size`` to pass to ``Encoder``</span>
<span class="sd">            - head_hidden_size (:obj:`Optional[int]`): The ``hidden_size`` to pass to ``Head``.</span>
<span class="sd">            - head_layer_num (:obj:`int`): The num of layers used in the network to compute Q value output</span>
<span class="sd">            - num_quantiles (:obj:`int`): Number of quantiles in the prediction distribution.</span>
<span class="sd">            - activation (:obj:`Optional[nn.Module]`):</span>
<span class="sd">                The type of activation function to use in ``MLP`` the after ``layer_fn``,</span>
<span class="sd">                if ``None`` then default set to ``nn.ReLU()``</span>
<span class="sd">            - norm_type (:obj:`Optional[str]`):</span>
<span class="sd">                The type of normalization to use, see ``ding.torch_utils.fc_block`` for more details`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">QRDQN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># For compatibility: 1, (1, ), [4, 32, 32]</span>
        <span class="n">obs_shape</span><span class="p">,</span> <span class="n">action_shape</span> <span class="o">=</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">),</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">action_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">head_hidden_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head_hidden_size</span> <span class="o">=</span> <span class="n">encoder_hidden_size_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># FC Encoder</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">FCEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="c1"># Conv Encoder</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ConvEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;not support obs_shape for pre-defined encoder: </span><span class="si">{}</span><span class="s2">, please customize your own QRDQN&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Head Type</span>
        <span class="n">multi_head</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">action_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multi_head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">MultiHead</span><span class="p">(</span>
                <span class="n">QRDQNHead</span><span class="p">,</span>
                <span class="n">head_hidden_size</span><span class="p">,</span>
                <span class="n">action_shape</span><span class="p">,</span>
                <span class="n">layer_num</span><span class="o">=</span><span class="n">head_layer_num</span><span class="p">,</span>
                <span class="n">num_quantiles</span><span class="o">=</span><span class="n">num_quantiles</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">QRDQNHead</span><span class="p">(</span>
                <span class="n">head_hidden_size</span><span class="p">,</span>
                <span class="n">action_shape</span><span class="p">,</span>
                <span class="n">head_layer_num</span><span class="p">,</span>
                <span class="n">num_quantiles</span><span class="o">=</span><span class="n">num_quantiles</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">,</span>
            <span class="p">)</span>

<div class="viewcode-block" id="QRDQN.forward"><a class="viewcode-back" href="../../../../hands_on/c51_qrdqn_iqn.html#ding.model.template.q_learning.QRDQN.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Use observation tensor to predict QRDQN&#39;s output.</span>
<span class="sd">            Parameter updates with QRDQN&#39;s MLPs forward setup.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - x (:obj:`torch.Tensor`):</span>
<span class="sd">                The encoded embedding tensor with ``(B, N=hidden_size)``.</span>
<span class="sd">        Returns:</span>
<span class="sd">            - outputs (:obj:`Dict`):</span>
<span class="sd">                Run with encoder and head. Return the result prediction dictionary.</span>

<span class="sd">        ReturnsKeys:</span>
<span class="sd">            - logit (:obj:`torch.Tensor`): Logit tensor with same size as input ``x``.</span>
<span class="sd">            - q (:obj:`torch.Tensor`): Q valye tensor tensor of size ``(B, N, num_quantiles)``</span>
<span class="sd">            - tau (:obj:`torch.Tensor`): tau tensor of size ``(B, N, 1)``</span>
<span class="sd">        Shapes:</span>
<span class="sd">            - x (:obj:`torch.Tensor`): :math:`(B, N)`, where B is batch size and N is head_hidden_size.</span>
<span class="sd">            - logit (:obj:`torch.FloatTensor`): :math:`(B, M)`, where M is action_shape.</span>
<span class="sd">            - tau (:obj:`torch.Tensor`):  :math:`(B, M, 1)`</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; model = QRDQN(64, 64)</span>
<span class="sd">            &gt;&gt;&gt; inputs = torch.randn(4, 64)</span>
<span class="sd">            &gt;&gt;&gt; outputs = model(inputs)</span>
<span class="sd">            &gt;&gt;&gt; assert isinstance(outputs, dict)</span>
<span class="sd">            &gt;&gt;&gt; assert outputs[&#39;logit&#39;].shape == torch.Size([4, 64])</span>
<span class="sd">            &gt;&gt;&gt; # default num_quantiles : int = 32</span>
<span class="sd">            &gt;&gt;&gt; assert outputs[&#39;q&#39;].shape == torch.Size([4, 64, 32])</span>
<span class="sd">            &gt;&gt;&gt; assert outputs[&#39;tau&#39;].shape == torch.Size([4, 32, 1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div></div>


<div class="viewcode-block" id="IQN"><a class="viewcode-back" href="../../../../hands_on/c51_qrdqn_iqn.html#ding.model.template.q_learning.IQN">[docs]</a><span class="nd">@MODEL_REGISTRY</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;iqn&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">IQN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">obs_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
            <span class="n">action_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
            <span class="n">encoder_hidden_size_list</span><span class="p">:</span> <span class="n">SequenceType</span> <span class="o">=</span> <span class="p">[</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span>
            <span class="n">head_hidden_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">head_layer_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">num_quantiles</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
            <span class="n">quantile_embedding_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
            <span class="n">activation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(),</span>
            <span class="n">norm_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Init the IQN Model according to input arguments.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - obs_shape (:obj:`Union[int, SequenceType]`): Observation space shape.</span>
<span class="sd">            - action_shape (:obj:`Union[int, SequenceType]`): Action space shape.</span>
<span class="sd">            - encoder_hidden_size_list (:obj:`SequenceType`): Collection of ``hidden_size`` to pass to ``Encoder``</span>
<span class="sd">            - head_hidden_size (:obj:`Optional[int]`): The ``hidden_size`` to pass to ``Head``.</span>
<span class="sd">            - head_layer_num (:obj:`int`): The num of layers used in the network to compute Q value output</span>
<span class="sd">            - num_quantiles (:obj:`int`): Number of quantiles in the prediction distribution.</span>
<span class="sd">            - activation (:obj:`Optional[nn.Module]`):</span>
<span class="sd">                The type of activation function to use in ``MLP`` the after ``layer_fn``,</span>
<span class="sd">                if ``None`` then default set to ``nn.ReLU()``</span>
<span class="sd">            - norm_type (:obj:`Optional[str]`):</span>
<span class="sd">                The type of normalization to use, see ``ding.torch_utils.fc_block`` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IQN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># For compatibility: 1, (1, ), [4, 32, 32]</span>
        <span class="n">obs_shape</span><span class="p">,</span> <span class="n">action_shape</span> <span class="o">=</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">),</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">action_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">head_hidden_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head_hidden_size</span> <span class="o">=</span> <span class="n">encoder_hidden_size_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># FC Encoder</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">FCEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="c1"># Conv Encoder</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ConvEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;not support obs_shape for pre-defined encoder: </span><span class="si">{}</span><span class="s2">, please customize your own IQN&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Head Type</span>
        <span class="n">head_cls</span> <span class="o">=</span> <span class="n">QuantileHead</span>
        <span class="n">multi_head</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">action_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multi_head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">MultiHead</span><span class="p">(</span>
                <span class="n">head_cls</span><span class="p">,</span>
                <span class="n">head_hidden_size</span><span class="p">,</span>
                <span class="n">action_shape</span><span class="p">,</span>
                <span class="n">layer_num</span><span class="o">=</span><span class="n">head_layer_num</span><span class="p">,</span>
                <span class="n">num_quantiles</span><span class="o">=</span><span class="n">num_quantiles</span><span class="p">,</span>
                <span class="n">quantile_embedding_size</span><span class="o">=</span><span class="n">quantile_embedding_size</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head_cls</span><span class="p">(</span>
                <span class="n">head_hidden_size</span><span class="p">,</span>
                <span class="n">action_shape</span><span class="p">,</span>
                <span class="n">head_layer_num</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">,</span>
                <span class="n">num_quantiles</span><span class="o">=</span><span class="n">num_quantiles</span><span class="p">,</span>
                <span class="n">quantile_embedding_size</span><span class="o">=</span><span class="n">quantile_embedding_size</span><span class="p">,</span>
            <span class="p">)</span>

<div class="viewcode-block" id="IQN.forward"><a class="viewcode-back" href="../../../../hands_on/c51_qrdqn_iqn.html#ding.model.template.q_learning.IQN.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Use encoded embedding tensor to predict IQN&#39;s output.</span>
<span class="sd">            Parameter updates with IQN&#39;s MLPs forward setup.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - x (:obj:`torch.Tensor`):</span>
<span class="sd">                The encoded embedding tensor with ``(B, N=hidden_size)``.</span>
<span class="sd">        Returns:</span>
<span class="sd">            - outputs (:obj:`Dict`):</span>
<span class="sd">                Run with encoder and head. Return the result prediction dictionary.</span>

<span class="sd">        ReturnsKeys:</span>
<span class="sd">            - logit (:obj:`torch.Tensor`): Logit tensor with same size as input ``x``.</span>
<span class="sd">            - q (:obj:`torch.Tensor`): Q valye tensor tensor of size ``(num_quantiles, N, B)``</span>
<span class="sd">            - quantiles (:obj:`torch.Tensor`): quantiles tensor of size ``(quantile_embedding_size, 1)``</span>
<span class="sd">        Shapes:</span>
<span class="sd">            - x (:obj:`torch.Tensor`): :math:`(B, N)`, where B is batch size and N is head_hidden_size.</span>
<span class="sd">            - logit (:obj:`torch.FloatTensor`): :math:`(B, M)`, where M is action_shape</span>
<span class="sd">            - quantiles (:obj:`torch.Tensor`):  :math:`(P, 1)`, where P is quantile_embedding_size.</span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; model = IQN(64, 64) # arguments: &#39;obs_shape&#39; and &#39;action_shape&#39;</span>
<span class="sd">            &gt;&gt;&gt; inputs = torch.randn(4, 64)</span>
<span class="sd">            &gt;&gt;&gt; outputs = model(inputs)</span>
<span class="sd">            &gt;&gt;&gt; assert isinstance(outputs, dict)</span>
<span class="sd">            &gt;&gt;&gt; assert outputs[&#39;logit&#39;].shape == torch.Size([4, 64])</span>
<span class="sd">            &gt;&gt;&gt; # default num_quantiles: int = 32</span>
<span class="sd">            &gt;&gt;&gt; assert outputs[&#39;q&#39;].shape == torch.Size([32, 4, 64]</span>
<span class="sd">            &gt;&gt;&gt; # default quantile_embedding_size: int = 128</span>
<span class="sd">            &gt;&gt;&gt; assert outputs[&#39;quantiles&#39;].shape == torch.Size([128, 1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div></div>


<div class="viewcode-block" id="RainbowDQN"><a class="viewcode-back" href="../../../../hands_on/rainbow.html#ding.model.template.q_learning.RainbowDQN">[docs]</a><span class="nd">@MODEL_REGISTRY</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;rainbowdqn&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">RainbowDQN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Overview:</span>
<span class="sd">        RainbowDQN network (C51 + Dueling + Noisy Block)</span>

<span class="sd">    .. note::</span>
<span class="sd">        RainbowDQN contains dueling architecture by default</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obs_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
        <span class="n">action_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
        <span class="n">encoder_hidden_size_list</span><span class="p">:</span> <span class="n">SequenceType</span> <span class="o">=</span> <span class="p">[</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span>
        <span class="n">head_hidden_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">head_layer_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">activation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(),</span>
        <span class="n">norm_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">v_min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">v_max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">n_atom</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">51</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Init the Rainbow Model according to arguments.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - obs_shape (:obj:`Union[int, SequenceType]`): Observation space shape.</span>
<span class="sd">            - action_shape (:obj:`Union[int, SequenceType]`): Action space shape.</span>
<span class="sd">            - encoder_hidden_size_list (:obj:`SequenceType`): Collection of ``hidden_size`` to pass to ``Encoder``</span>
<span class="sd">            - head_hidden_size (:obj:`Optional[int]`): The ``hidden_size`` to pass to ``Head``.</span>
<span class="sd">            - head_layer_num (:obj:`int`): The num of layers used in the network to compute Q value output</span>
<span class="sd">            - activation (:obj:`Optional[nn.Module]`): The type of activation function to use in ``MLP`` the after \</span>
<span class="sd">                ``layer_fn``, if ``None`` then default set to ``nn.ReLU()``</span>
<span class="sd">            - norm_type (:obj:`Optional[str]`): The type of normalization to use, see ``ding.torch_utils.fc_block`` \</span>
<span class="sd">                for more details`</span>
<span class="sd">            - n_atom (:obj:`Optional[int]`): Number of atoms in the prediction distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RainbowDQN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># For compatibility: 1, (1, ), [4, 32, 32]</span>
        <span class="n">obs_shape</span><span class="p">,</span> <span class="n">action_shape</span> <span class="o">=</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">),</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">action_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">head_hidden_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head_hidden_size</span> <span class="o">=</span> <span class="n">encoder_hidden_size_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># FC Encoder</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">FCEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="c1"># Conv Encoder</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ConvEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;not support obs_shape for pre-defined encoder: </span><span class="si">{}</span><span class="s2">, please customize your own RainbowDQN&quot;</span><span class="o">.</span>
                <span class="nb">format</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Head Type</span>
        <span class="n">multi_head</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">action_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multi_head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">MultiHead</span><span class="p">(</span>
                <span class="n">RainbowHead</span><span class="p">,</span>
                <span class="n">head_hidden_size</span><span class="p">,</span>
                <span class="n">action_shape</span><span class="p">,</span>
                <span class="n">layer_num</span><span class="o">=</span><span class="n">head_layer_num</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">,</span>
                <span class="n">n_atom</span><span class="o">=</span><span class="n">n_atom</span><span class="p">,</span>
                <span class="n">v_min</span><span class="o">=</span><span class="n">v_min</span><span class="p">,</span>
                <span class="n">v_max</span><span class="o">=</span><span class="n">v_max</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">RainbowHead</span><span class="p">(</span>
                <span class="n">head_hidden_size</span><span class="p">,</span>
                <span class="n">action_shape</span><span class="p">,</span>
                <span class="n">head_layer_num</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">,</span>
                <span class="n">n_atom</span><span class="o">=</span><span class="n">n_atom</span><span class="p">,</span>
                <span class="n">v_min</span><span class="o">=</span><span class="n">v_min</span><span class="p">,</span>
                <span class="n">v_max</span><span class="o">=</span><span class="n">v_max</span><span class="p">,</span>
            <span class="p">)</span>

<div class="viewcode-block" id="RainbowDQN.forward"><a class="viewcode-back" href="../../../../hands_on/rainbow.html#ding.model.template.q_learning.RainbowDQN.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Use observation tensor to predict Rainbow output.</span>
<span class="sd">            Parameter updates with Rainbow&#39;s MLPs forward setup.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - x (:obj:`torch.Tensor`):</span>
<span class="sd">                The encoded embedding tensor with ``(B, N=hidden_size)``.</span>
<span class="sd">        Returns:</span>
<span class="sd">            - outputs (:obj:`Dict`):</span>
<span class="sd">                Run ``MLP`` with ``RainbowHead`` setups and return the result prediction dictionary.</span>

<span class="sd">        ReturnsKeys:</span>
<span class="sd">            - logit (:obj:`torch.Tensor`): Logit tensor with same size as input ``x``.</span>
<span class="sd">            - distribution (:obj:`torch.Tensor`): Distribution tensor of size ``(B, N, n_atom)``</span>
<span class="sd">        Shapes:</span>
<span class="sd">            - x (:obj:`torch.Tensor`): :math:`(B, N)`, where B is batch size and N is head_hidden_size.</span>
<span class="sd">            - logit (:obj:`torch.FloatTensor`): :math:`(B, M)`, where M is action_shape.</span>
<span class="sd">            - distribution(:obj:`torch.FloatTensor`): :math:`(B, M, P)`, where P is n_atom.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; model = RainbowDQN(64, 64) # arguments: &#39;obs_shape&#39; and &#39;action_shape&#39;</span>
<span class="sd">            &gt;&gt;&gt; inputs = torch.randn(4, 64)</span>
<span class="sd">            &gt;&gt;&gt; outputs = model(inputs)</span>
<span class="sd">            &gt;&gt;&gt; assert isinstance(outputs, dict)</span>
<span class="sd">            &gt;&gt;&gt; assert outputs[&#39;logit&#39;].shape == torch.Size([4, 64])</span>
<span class="sd">            &gt;&gt;&gt; # default n_atom: int =51</span>
<span class="sd">            &gt;&gt;&gt; assert outputs[&#39;distribution&#39;].shape == torch.Size([4, 64, 51])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div></div>


<span class="k">def</span> <span class="nf">parallel_wrapper</span><span class="p">(</span><span class="n">forward_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Overview:</span>
<span class="sd">        Process timestep T and batch_size B at the same time, in other words, treat different timestep data as</span>
<span class="sd">        different trajectories in a batch.</span>
<span class="sd">    Arguments:</span>
<span class="sd">        - forward_fn (:obj:`Callable`): Normal ``nn.Module`` &#39;s forward function.</span>
<span class="sd">    Returns:</span>
<span class="sd">        - wrapper (:obj:`Callable`): Wrapped function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">return</span> <span class="n">d</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">forward_fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="nd">@MODEL_REGISTRY</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;drqn&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">DRQN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Overview:</span>
<span class="sd">        DQN + RNN = DRQN</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">obs_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
            <span class="n">action_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
            <span class="n">encoder_hidden_size_list</span><span class="p">:</span> <span class="n">SequenceType</span> <span class="o">=</span> <span class="p">[</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span>
            <span class="n">dueling</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">head_hidden_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">head_layer_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">lstm_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;normal&#39;</span><span class="p">,</span>
            <span class="n">activation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(),</span>
            <span class="n">norm_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">res_link</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Init the DRQN Model according to arguments.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - obs_shape (:obj:`Union[int, SequenceType]`): Observation&#39;s space.</span>
<span class="sd">            - action_shape (:obj:`Union[int, SequenceType]`): Action&#39;s space.</span>
<span class="sd">            - encoder_hidden_size_list (:obj:`SequenceType`): Collection of ``hidden_size`` to pass to ``Encoder``</span>
<span class="sd">            - head_hidden_size (:obj:`Optional[int]`): The ``hidden_size`` to pass to ``Head``.</span>
<span class="sd">            - lstm_type (:obj:`Optional[str]`): Version of rnn cell, now support [&#39;normal&#39;, &#39;pytorch&#39;, &#39;hpc&#39;, &#39;gru&#39;]</span>
<span class="sd">            - activation (:obj:`Optional[nn.Module]`):</span>
<span class="sd">                The type of activation function to use in ``MLP`` the after ``layer_fn``,</span>
<span class="sd">                if ``None`` then default set to ``nn.ReLU()``</span>
<span class="sd">            - norm_type (:obj:`Optional[str]`):</span>
<span class="sd">                The type of normalization to use, see ``ding.torch_utils.fc_block`` for more details`</span>
<span class="sd">            - res_link (:obj:`bool`): use the residual link or not, default to False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DRQN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># For compatibility: 1, (1, ), [4, 32, 32]</span>
        <span class="n">obs_shape</span><span class="p">,</span> <span class="n">action_shape</span> <span class="o">=</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">),</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">action_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">head_hidden_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head_hidden_size</span> <span class="o">=</span> <span class="n">encoder_hidden_size_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># FC Encoder</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">FCEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="c1"># Conv Encoder</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">ConvEncoder</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;not support obs_shape for pre-defined encoder: </span><span class="si">{}</span><span class="s2">, please customize your own DRQN&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># LSTM Type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span> <span class="o">=</span> <span class="n">get_lstm</span><span class="p">(</span><span class="n">lstm_type</span><span class="p">,</span> <span class="n">input_size</span><span class="o">=</span><span class="n">head_hidden_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="o">=</span><span class="n">head_hidden_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_link</span> <span class="o">=</span> <span class="n">res_link</span>
        <span class="c1"># Head Type</span>
        <span class="k">if</span> <span class="n">dueling</span><span class="p">:</span>
            <span class="n">head_cls</span> <span class="o">=</span> <span class="n">DuelingHead</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head_cls</span> <span class="o">=</span> <span class="n">DiscreteHead</span>
        <span class="n">multi_head</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">action_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multi_head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">MultiHead</span><span class="p">(</span>
                <span class="n">head_cls</span><span class="p">,</span>
                <span class="n">head_hidden_size</span><span class="p">,</span>
                <span class="n">action_shape</span><span class="p">,</span>
                <span class="n">layer_num</span><span class="o">=</span><span class="n">head_layer_num</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head_cls</span><span class="p">(</span>
                <span class="n">head_hidden_size</span><span class="p">,</span> <span class="n">action_shape</span><span class="p">,</span> <span class="n">head_layer_num</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">inference</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">saved_hidden_state_timesteps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Use observation tensor to predict DRQN output.</span>
<span class="sd">            Parameter updates with DRQN&#39;s MLPs forward setup.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - inputs (:obj:`Dict`):</span>
<span class="sd">            - inference: (:obj:&#39;bool&#39;): if inference is True, we unroll the one timestep transition,</span>
<span class="sd">                if inference is False, we unroll the sequence transitions.</span>
<span class="sd">            - saved_hidden_state_timesteps: (:obj:&#39;Optional[list]&#39;): when inference is False,</span>
<span class="sd">                we unroll the sequence transitions, then we would save rnn hidden states at timesteps</span>
<span class="sd">                that are listed in list saved_hidden_state_timesteps.</span>

<span class="sd">       ArgumentsKeys:</span>
<span class="sd">            - obs (:obj:`torch.Tensor`): Encoded observation</span>
<span class="sd">            - prev_state (:obj:`list`): Previous state&#39;s tensor of size ``(B, N)``</span>

<span class="sd">        Returns:</span>
<span class="sd">            - outputs (:obj:`Dict`):</span>
<span class="sd">                Run ``MLP`` with ``DRQN`` setups and return the result prediction dictionary.</span>

<span class="sd">        ReturnsKeys:</span>
<span class="sd">            - logit (:obj:`torch.Tensor`): Logit tensor with same size as input ``obs``.</span>
<span class="sd">            - next_state (:obj:`list`): Next state&#39;s tensor of size ``(B, N)``</span>
<span class="sd">        Shapes:</span>
<span class="sd">            - obs (:obj:`torch.Tensor`): :math:`(B, N=obs_space)`, where B is batch size.</span>
<span class="sd">            - prev_state(:obj:`torch.FloatTensor list`): :math:`[(B, N)]`</span>
<span class="sd">            - logit (:obj:`torch.FloatTensor`): :math:`(B, N)`</span>
<span class="sd">            - next_state(:obj:`torch.FloatTensor list`): :math:`[(B, N)]`</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Init input&#39;s Keys:</span>
<span class="sd">            &gt;&gt;&gt; prev_state = [[torch.randn(1, 1, 64) for __ in range(2)] for _ in range(4)] # B=4</span>
<span class="sd">            &gt;&gt;&gt; obs = torch.randn(4,64)</span>
<span class="sd">            &gt;&gt;&gt; model = DRQN(64, 64) # arguments: &#39;obs_shape&#39; and &#39;action_shape&#39;</span>
<span class="sd">            &gt;&gt;&gt; outputs = model({&#39;obs&#39;: inputs, &#39;prev_state&#39;: prev_state}, inference=True)</span>
<span class="sd">            &gt;&gt;&gt; # Check outputs&#39;s Keys</span>
<span class="sd">            &gt;&gt;&gt; assert isinstance(outputs, dict)</span>
<span class="sd">            &gt;&gt;&gt; assert outputs[&#39;logit&#39;].shape == (4, 64)</span>
<span class="sd">            &gt;&gt;&gt; assert len(outputs[&#39;next_state&#39;]) == 4</span>
<span class="sd">            &gt;&gt;&gt; assert all([len(t) == 2 for t in outputs[&#39;next_state&#39;]])</span>
<span class="sd">            &gt;&gt;&gt; assert all([t[0].shape == (1, 1, 64) for t in outputs[&#39;next_state&#39;]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">prev_state</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">],</span> <span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;prev_state&#39;</span><span class="p">]</span>
        <span class="c1"># for both inference and other cases, the network structure is encoder -&gt; rnn network -&gt; head</span>
        <span class="c1"># the difference is inference take the data with seq_len=1 (or T = 1)</span>
        <span class="k">if</span> <span class="n">inference</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_link</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># for rnn input, put the seq_len of x as 1 instead of none.</span>
            <span class="c1"># prev_state: DataType: List[Tuple[torch.Tensor]]; Initially, it is a list of None</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">next_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_state</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># to delete the seq_len dim to match head network input</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_link</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="s1">&#39;next_state&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_state</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">parallel_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># (T, B, N)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_link</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">lstm_embedding</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># TODO(nyz) how to deal with hidden_size key-value</span>
            <span class="n">hidden_state_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">saved_hidden_state_timesteps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">saved_hidden_state</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>  <span class="c1"># T timesteps</span>
                <span class="n">output</span><span class="p">,</span> <span class="n">prev_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">:</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">prev_state</span><span class="p">)</span>  <span class="c1"># output: (1,B, head_hidden_size)</span>
                <span class="k">if</span> <span class="n">saved_hidden_state_timesteps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">saved_hidden_state_timesteps</span><span class="p">:</span>
                    <span class="n">saved_hidden_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_state</span><span class="p">)</span>
                <span class="n">lstm_embedding</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
                <span class="n">hidden_state</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">prev_state</span><span class="p">))</span>  <span class="c1"># {list: 2{tuple: B{Tensor:(1, 1, head_hidden_size}}}</span>
                <span class="c1"># only keep ht, {list: x.shape[0]{Tensor:(1, batch_size, head_hidden_size)}}</span>
                <span class="n">hidden_state_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">hidden_state</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">lstm_embedding</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># (T, B, head_hidden_size)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_link</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">parallel_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># (T, B, action_shape)</span>
            <span class="c1"># the last timestep state including h and c for lstm, {list: B{tuple: 2{Tensor:(1, 1, head_hidden_size}}}</span>
            <span class="n">x</span><span class="p">[</span><span class="s1">&#39;next_state&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_state</span>
            <span class="c1"># all hidden state h, this returns a tensor of the dim: seq_len*batch_size*head_hidden_size</span>
            <span class="c1"># This key is used in qtran, the algorithm requires to retain all h_{t} during training</span>
            <span class="n">x</span><span class="p">[</span><span class="s1">&#39;hidden_state&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">hidden_state_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">saved_hidden_state_timesteps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span><span class="p">[</span><span class="s1">&#39;saved_hidden_state&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">saved_hidden_state</span>  <span class="c1"># the selected saved hidden states, including h and c</span>
            <span class="k">return</span> <span class="n">x</span>


<span class="nd">@MODEL_REGISTRY</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;gtrxl_discrete&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">GTrXLDiscreteHead</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Overview:</span>
<span class="sd">        Add a discrete head on top of the GTrXL module.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obs_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
        <span class="n">action_shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">],</span>
        <span class="n">head_layer_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">att_head_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">hidden_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">att_head_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">att_mlp_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">att_layer_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">memory_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
        <span class="n">activation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(),</span>
        <span class="n">head_norm_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dropout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span>
        <span class="n">gru_gating</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">gru_bias</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.</span><span class="p">,</span>
        <span class="n">dueling</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">encoder_hidden_size_list</span><span class="p">:</span> <span class="n">SequenceType</span> <span class="o">=</span> <span class="p">[</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">],</span>
        <span class="n">encoder_norm_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Init the model according to arguments.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            Refer to GTrXl class in `ding.torch_utils.network.gtrxl` for more details about the input arguments.</span>
<span class="sd">            - obs_shape (:obj:`Union[int, SequenceType]`): Used by Transformer. Observation&#39;s space.</span>
<span class="sd">            - action_shape (:obj:Union[int, SequenceType]): Used by Head. Action&#39;s space.</span>
<span class="sd">            - head_layer_num (:obj:`int`): Used by Head. Number of layers.</span>
<span class="sd">            - att_head_dim (:obj:`int`): Used by Transformer.</span>
<span class="sd">            - hidden_size (:obj:`int`): Used by Transformer and Head.</span>
<span class="sd">            - att_head_num (:obj:`int`): Used by Transformer.</span>
<span class="sd">            - att_mlp_num (:obj:`int`): Used by Transformer.</span>
<span class="sd">            - att_layer_num (:obj:`int`): Used by Transformer.</span>
<span class="sd">            - memory_len (:obj:`int`): Used by Transformer.</span>
<span class="sd">            - activation (:obj:`Optional[nn.Module]`): Used by Transformer and Head. if ``None`` then default set to</span>
<span class="sd">             ``nn.ReLU()``.</span>
<span class="sd">            - head_norm_type (:obj:`Optional[str]`): Used by Head. The type of normalization to use, see</span>
<span class="sd">             ``ding.torch_utils.fc_block`` for more details`.</span>
<span class="sd">            - dropout (:obj:`bool`): Used by Transformer.</span>
<span class="sd">            - gru_gating (:obj:`bool`): Used by Transformer.</span>
<span class="sd">            - gru_bias (:obj:`float`): Used by Transformer.</span>
<span class="sd">            - dueling (:obj:`bool`): Used by Head. Make the head dueling.</span>
<span class="sd">            - encoder_hidden_size_list(:obj:`SequenceType`): Used by Encoder. The collection of ``hidden_size`` if using</span>
<span class="sd">              a custom convolutional encoder.</span>
<span class="sd">            - encoder_norm_type (:obj:`Optional[str]`): Used by Encoder. The type of normalization to use, see</span>
<span class="sd">             ``ding.torch_utils.fc_block`` for more details`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GTrXLDiscreteHead</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core</span> <span class="o">=</span> <span class="n">GTrXL</span><span class="p">(</span>
            <span class="n">input_dim</span><span class="o">=</span><span class="n">obs_shape</span><span class="p">,</span>
            <span class="n">head_dim</span><span class="o">=</span><span class="n">att_head_dim</span><span class="p">,</span>
            <span class="n">embedding_dim</span><span class="o">=</span><span class="n">hidden_size</span><span class="p">,</span>
            <span class="n">head_num</span><span class="o">=</span><span class="n">att_head_num</span><span class="p">,</span>
            <span class="n">mlp_num</span><span class="o">=</span><span class="n">att_mlp_num</span><span class="p">,</span>
            <span class="n">layer_num</span><span class="o">=</span><span class="n">att_layer_num</span><span class="p">,</span>
            <span class="n">memory_len</span><span class="o">=</span><span class="n">memory_len</span><span class="p">,</span>
            <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
            <span class="n">dropout_ratio</span><span class="o">=</span><span class="n">dropout</span><span class="p">,</span>
            <span class="n">gru_gating</span><span class="o">=</span><span class="n">gru_gating</span><span class="p">,</span>
            <span class="n">gru_bias</span><span class="o">=</span><span class="n">gru_bias</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># replace the embedding layer of Transformer with Conv Encoder</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">encoder_hidden_size_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">hidden_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs_encoder</span> <span class="o">=</span> <span class="n">ConvEncoder</span><span class="p">(</span>
                <span class="n">obs_shape</span><span class="p">,</span> <span class="n">encoder_hidden_size_list</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">encoder_norm_type</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">dropout</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">use_embedding_layer</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;not support obs_shape for pre-defined encoder: </span><span class="si">{}</span><span class="s2">, please customize your own GTrXL&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obs_shape</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Head Type</span>
        <span class="k">if</span> <span class="n">dueling</span><span class="p">:</span>
            <span class="n">head_cls</span> <span class="o">=</span> <span class="n">DuelingHead</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head_cls</span> <span class="o">=</span> <span class="n">DiscreteHead</span>
        <span class="n">multi_head</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">action_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multi_head</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">MultiHead</span><span class="p">(</span>
                <span class="n">head_cls</span><span class="p">,</span>
                <span class="n">hidden_size</span><span class="p">,</span>
                <span class="n">action_shape</span><span class="p">,</span>
                <span class="n">layer_num</span><span class="o">=</span><span class="n">head_layer_num</span><span class="p">,</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                <span class="n">norm_type</span><span class="o">=</span><span class="n">head_norm_type</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head_cls</span><span class="p">(</span>
                <span class="n">hidden_size</span><span class="p">,</span> <span class="n">action_shape</span><span class="p">,</span> <span class="n">head_layer_num</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="n">head_norm_type</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Let input tensor go through GTrXl and the Head sequentially.</span>
<span class="sd">        Arguments:</span>
<span class="sd">            - x (:obj:`torch.Tensor`): input tensor of shape (seq_len, bs, obs_shape).</span>
<span class="sd">        Returns:</span>
<span class="sd">            - out (:obj:`Dict`): run ``GTrXL`` with ``DiscreteHead`` setups and return the result prediction dictionary.</span>
<span class="sd">            Necessary Keys:</span>
<span class="sd">                - logit (:obj:`torch.Tensor`): discrete Q-value output of each action dimension.</span>
<span class="sd">                 Shape is (bs, action_space)</span>
<span class="sd">                - memory (:obj:`torch.Tensor`):</span>
<span class="sd">                memory tensor of size ``(bs x layer_num+1 x memory_len x embedding_dim)``</span>
<span class="sd">                - transformer_out (:obj:`torch.Tensor`): output tensor of transformer with same size as input ``x``.</span>
<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Init input&#39;s Keys:</span>
<span class="sd">            &gt;&gt;&gt; obs_dim, seq_len, bs, action_dim = 128, 64, 32, 4</span>
<span class="sd">            &gt;&gt;&gt; obs = torch.rand(seq_len, bs, obs_dim)</span>
<span class="sd">            &gt;&gt;&gt; model = GTrXLDiscreteHead(obs_dim, action_dim)</span>
<span class="sd">            &gt;&gt;&gt; outputs = model(obs)</span>
<span class="sd">            &gt;&gt;&gt; assert isinstance(outputs, dict)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="c1"># 3d obs: cur_seq, bs, ch, h, w</span>
            <span class="n">x_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]))</span>
            <span class="n">x_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs_encoder</span><span class="p">(</span><span class="n">x_</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x_</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">o1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">o1</span><span class="p">[</span><span class="s1">&#39;logit&#39;</span><span class="p">])</span>
        <span class="c1"># layer_num+1 x memory_len x bs embedding_dim -&gt; bs x layer_num+1 x memory_len x embedding_dim</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;memory&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">o1</span><span class="p">[</span><span class="s1">&#39;memory&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;transformer_out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">o1</span><span class="p">[</span><span class="s1">&#39;logit&#39;</span><span class="p">]</span>  <span class="c1"># output of gtrxl, out[&#39;logit&#39;] is final output</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">reset_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Clear or set the memory of GTrXL.</span>
<span class="sd">         Arguments:</span>
<span class="sd">            - batch_size (:obj:`Optional[int]`): batch size</span>
<span class="sd">            - state (:obj:`Optional[torch.Tensor]`): input memory.</span>
<span class="sd">            Shape is (layer_num, memory_len, bs, embedding_dim).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">reset_memory</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overview:</span>
<span class="sd">            Return the memory of GTrXL.</span>
<span class="sd">        Returns:</span>
<span class="sd">            - memory: (:obj:`Optional[torch.Tensor]`): output memory or None if memory has not been initialized.</span>
<span class="sd">            Shape is (layer_num, memory_len, bs, embedding_dim).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">GeneralQNetwork</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, OpenDILab Contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>