

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Learner Overview &mdash; DI-engine 0.1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Wrapper &amp; Hook Overview" href="wrapper_hook_overview.html" />
    <link rel="prev" title="Replay Buffer Overview" href="replay_buffer_overview.html" />
    <link href="../_static/css/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> DI-engine
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quick_start/index.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../key_concept/index.html">Key Concept</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro_rl/index.html">Introduction to RL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hands_on/index.html">RL Algorithm Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../env_tutorial/index.html">RL Environments Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../distributed/index.html">Distributed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../best_practice/index.html">Best Practice</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api_doc/index.html">API Doc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Feature</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="algorithm_overview.html">Algorithm Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="policy_overview.html">Policy Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="model_overview.html">Model Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="env_overview.html">Env Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="collector_overview.html">Collector Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="env_manager_overview.html">Env Manager Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="replay_buffer_overview.html">Replay Buffer Overview</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Learner Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-learner">Base Learner</a></li>
<li class="toctree-l3"><a class="reference internal" href="#learnerhook">LearnerHook</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basecommlearner">BaseCommLearner</a></li>
<li class="toctree-l3"><a class="reference internal" href="#analysis-of-training-process-in-parallel-mode">Analysis of Training Process in Parallel Mode</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="wrapper_hook_overview.html">Wrapper &amp; Hook Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="league_overview.html">League Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc_rl_overview.html">DI-hpc Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="orchestrator_overview.html">DI-orchestrator Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="interaction_overview.html">Interaction Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="loader_overview.html">Loader Overview</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guide/index.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial_dev/index.html">Tutorial-Developer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture/index.html">Architecture Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../specification/index.html">Middleware code specification</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DI-engine</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Feature</a> &raquo;</li>
        
      <li>Learner Overview</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/feature/learner_overview.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="learner-overview">
<h1>Learner Overview<a class="headerlink" href="#learner-overview" title="Permalink to this headline">¶</a></h1>
<p>Learner code can be mainly divided into three parts：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>learner:</p></li>
<li><p>hook: Do some jobs at specific timings, e.g. save/load checkpoint, print log.</p></li>
<li><p>comm: Used in parallel mode to communicate with coordinator.</p></li>
</ol>
</div></blockquote>
<div class="section" id="base-learner">
<h2>Base Learner<a class="headerlink" href="#base-learner" title="Permalink to this headline">¶</a></h2>
<p>(ding/worker/learner/base_learner.py)</p>
<dl class="simple">
<dt>Overview:</dt><dd><p>Base learner is the actual part for policy optimization given training data. It provides different interfaces for serial and parallel mode.</p>
</dd>
<dt>Variables:</dt><dd><p>learn_info, priority_info, last_iter, name, rank, policy
tick_time, monitor, log_buffer, logger, tb_logger</p>
</dd>
<dt>Class interface method:</dt><dd><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">train</span></code>: Interface for serial pipeline. Given training data, train for one iteration.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">call_hook</span></code>:  Call all hooks at a specific timing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">register_hook</span></code>: Register a new hook to the learner.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">save_checkpoint</span></code>:  Save current state_dict as a checkpoint.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code>: [For parallel mode] Start parallel learner training. In this method calls <code class="docutils literal notranslate"><span class="pre">train</span></code> for one-iteration training</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">setup_dataloader</span></code>: [For parallel mode] Set up the dataloader.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">close</span></code>: [For parallel mode] Finish parallel learning training and releasing all resources.</p></li>
</ol>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In <strong>serial pipeline</strong>, learner and collector one by one, i.e. synchronous. So <code class="docutils literal notranslate"><span class="pre">train</span></code> method gets training data from outside(Usually sample from replay buffer).</p>
<p>While in <strong>parallel pipeline</strong> , learner and collector are both working at the same time, i.e. asynchronous. So <code class="docutils literal notranslate"><span class="pre">start</span></code> method can start the training process. In which process, learner fetches data from dataloader(From here we can see that dataloader only exists in parallel mode, not in serial mode) and training for many iterations, until reaches max_iteration or evaluation reaches stop_value. In each iteration, <code class="docutils literal notranslate"><span class="pre">start</span></code> actually call <code class="docutils literal notranslate"><span class="pre">train</span></code> to do a one-iteration training.</p>
</div>
</div>
<div class="section" id="learnerhook">
<h2>LearnerHook<a class="headerlink" href="#learnerhook" title="Permalink to this headline">¶</a></h2>
<p>(ding/worker/learner/learner_hook.py)</p>
<dl class="simple">
<dt>Overview:</dt><dd><p>Hook is a module do some specific jobs. Learner hook is a derived abstract class, which adds the concept of “Position”. So learner can call hook at different timings.</p>
</dd>
<dt>Variables:</dt><dd><p>name, priority, position</p>
</dd>
<dt>Abstract class interface method for base hook class:</dt><dd><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__init__</span></code>: Initialization.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__call__</span></code>: Do the jobs of the hook. Derived class must override this method.</p></li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="basecommlearner">
<h2>BaseCommLearner<a class="headerlink" href="#basecommlearner" title="Permalink to this headline">¶</a></h2>
<p>(ding/worker/learner/base_comm_learner.py)</p>
<dl>
<dt>Overview:</dt><dd><p>The base learner can independently complete the training work in serial pipeline; But for parallel pipeline, although the training interface is provided, there are still some problems remaining. For example, how to obtain data, how to communicate with the outside(coordinator, in DI-engine case), etc. Comm learner is the module which is responsible for solving these problems in parallel mode.</p>
<p>The comm learner does not actually perform training. It holds a base learner and solves communication-related problems for it. And actual training is still done by base learner.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Therefore, serial pipeline can instantiate the base learner and use it directly; But in parallel pipeline, the comm learner should be instantiated, and then the comm learner creates the base learner through <code class="docutils literal notranslate"><span class="pre">_create_learner</span></code>.</p>
</div>
<p>In parallel mode, the learner needs to send out the data request by itself, and send current policy &amp; learner information regularly. These operations will be completed by hooks. An important job of the comm learner is to register these hooks into the learner, that is, return the above hooks in <code class="docutils literal notranslate"><span class="pre">hooks4call</span></code> method. Also, there are some functions that are needed in hooks, such as <code class="docutils literal notranslate"><span class="pre">get_data</span></code>, <code class="docutils literal notranslate"><span class="pre">send_policy</span></code>, <code class="docutils literal notranslate"><span class="pre">send_learn_info</span></code>. Comm learner should also implement those functions.</p>
</dd>
<dt>Variables:</dt><dd><p>None</p>
</dd>
<dt>Class interface method:</dt><dd><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__init__</span></code>: Initialization.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code>: Start comm learner service.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">close</span></code>: Close comm learner service.</p></li>
</ol>
</dd>
<dt>Abstract class interface method that should be overriden by derived class:</dt><dd><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">get_data</span></code>: The function to fetch data. A parameter of <code class="docutils literal notranslate"><span class="pre">AsyncDataloader</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">send_policy</span></code>: Store current policy to file system, so that collector can update its own policy on time.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">send_learn_info</span></code>: Send learn info to coordinator periodically.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hooks4call</span></code>: A dict containing all hooks to send policy or learn_info.</p></li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="analysis-of-training-process-in-parallel-mode">
<h2>Analysis of Training Process in Parallel Mode<a class="headerlink" href="#analysis-of-training-process-in-parallel-mode" title="Permalink to this headline">¶</a></h2>
<p>Compared with the simple and easily understood serial mode, the parallel mode is more obscure due to the communication problems between the asynchronously running learner and collectors. Therefore, in this part, we will use the <code class="docutils literal notranslate"><span class="pre">FlaskFileSystemLearner</span></code> (<code class="docutils literal notranslate"><span class="pre">ding/worker/learner/comm/flask_fs_learner.py</span></code>), a derived comm learner that uses <strong>flask and file system to communicate</strong>, as an example to introduce the parallel mode. The mode analysis includes those procedures:</p>
<blockquote>
<div><ul class="simple">
<li><p>parallel pipeline entry deploying the coordinator</p></li>
<li><p>comm learner starting</p></li>
<li><p>communication connection being established between coordinator and comm learner</p></li>
<li><p>coordinator starting the comm learner and assigning tasks to it one or more times</p></li>
<li><p>coordinator and comm learner closing the communication connection</p></li>
</ul>
</div></blockquote>
<img alt="../_images/parallel_learner_sequence.jpg" src="../_images/parallel_learner_sequence.jpg" />
<p>The above sequence diagram shows the process of coordinator and comm learner from being deployed in parallel pipeline, to establishing connection, to assigning actual task and executing, and finally to disconnection. As for the core, assigning actual task and executing, please continue reading.</p>
<p>Before introducing FlaskFileSystemLearner, it is necessary to introduce <code class="docutils literal notranslate"><span class="pre">LearnerSlave</span></code>, the class that is actually responsible for <strong>communicating with coordinator</strong>. LearnerSlave is derived from <code class="docutils literal notranslate"><span class="pre">Slave</span></code>. Its master is the attribute master in coordinator. LearnerSlave’s tasks include: processing tasks sent by the master, responding to the corresponding tasks using the callback functions passed by FlaskFileSystemLearner. Its essence is to use the master-slave mechanism to help FlaskFileSystemLearner complete the communication with the coordinator.</p>
<p>The relationship among the BaseCommLearner, FlaskFileSystemLearner, BaseLearner, LearnerSlave classes can be seen in the class diagram (This class diagram is not complete, because it only contains the parts essenntial to understanding the workflow described later):</p>
<img alt="../_images/comm_learner_class.jpg" src="../_images/comm_learner_class.jpg" />
<p>Then we start to introduce the workflow of FlaskFileSystemLearner, that is, the assignment and execution process of actual tasks, which is also the omitted part of the first sequence diagram. You can refer to the following sequence diagram to help understand.</p>
<img alt="../_images/comm_learner_sequence.jpg" src="../_images/comm_learner_sequence.jpg" />
<ol class="arabic">
<li><p>Create comm learner</p>
<blockquote>
<div><p>Parallel pipeline will create a comm learner and call its <code class="docutils literal notranslate"><span class="pre">start</span></code> method to start the comm learner service</p>
<p>In comm learner, a <strong>learner slave</strong> is first instantiated, and comm learner’s four functions are passed to the learner slave as callback functions (as for what is the callback function and what the callback function is used for, we will explain afterwards), learner slave will establish a connection with the coordinator through the pre-agreed ip address and port number.</p>
<p>In addition, comm learner creates several <strong>length == 1 queues</strong> to store some message dicts related to communication.</p>
</div></blockquote>
</li>
<li><p>Create learner</p>
<blockquote>
<div><p>Before coordinator sends the task, comm learner and learner slave are always on standby. Once the coordinator sends a task, the <code class="docutils literal notranslate"><span class="pre">_process_task</span></code> of the learner slave will receive the task.</p>
<p>Coordinator knows the workflow of comm learner is: <strong>First establish a learner, and then repeat the process of acquiring data and training with data until the end</strong>. Therefore, the current task should be <code class="docutils literal notranslate"><span class="pre">learner_start_task</span></code>, coordinator also passes information necessary to establish a learner.</p>
<p>The information is passed to the learner slave, but the creation of the learner is in the comm learner. Here uses the <strong>callback function</strong> we mentioned just now. The callback function is implemented by comm learner, but is passed to the learner slave as a parameter, so the learner slave can call these functions.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">learner_start_task</span></code>, the learner slave calls the <code class="docutils literal notranslate"><span class="pre">deal_with_learner_start</span></code> method of comm learner to complete the work of establishing the learner. After completion, the learner slave returns a successful message to the coordinator.</p>
</div></blockquote>
</li>
<li><p>Learner get data</p>
<blockquote>
<div><p>After learner is established, dataloader will call <code class="docutils literal notranslate"><span class="pre">get_data</span></code> method implemented in the comm learner to make an attempt to get data. <code class="docutils literal notranslate"><span class="pre">get_data</span></code> will put the request in the <code class="docutils literal notranslate"><span class="pre">_data_demand_queue</span></code> of the comm learner, then try fetching data from <code class="docutils literal notranslate"><span class="pre">_data_result_queue</span></code>. If it is empty, it is <strong>blocked</strong> here.</p>
<p>Let’s return back to the coordinator, when the coordinator receives the information that <code class="docutils literal notranslate"><span class="pre">learner_start_task</span></code> was successfully executed, it sends the task <code class="docutils literal notranslate"><span class="pre">learner_get_data_task</span></code>. And learner slave calls <code class="docutils literal notranslate"><span class="pre">deal_with_get_data</span></code> in comm learner to take out the request in <code class="docutils literal notranslate"><span class="pre">_data_demand_queue</span></code>, then returns it to the coordinator.</p>
</div></blockquote>
</li>
<li><p>Learner train</p>
<blockquote>
<div><p>After coordinator receives the learner’s data request, it will send <code class="docutils literal notranslate"><span class="pre">learner_learn_task</span></code> to the learner slave, which contains the <strong>data</strong> (or metadata) requested by the learner. After the learner slave receives it, it calls the <code class="docutils literal notranslate"><span class="pre">deal_with_learner_learn</span></code> method of the comm learner, puts the received data information into the <code class="docutils literal notranslate"><span class="pre">_data_result_queue</span></code>, and waits for the learner to finish training, and the training information can be obtained from the <code class="docutils literal notranslate"><span class="pre">_learn_info_queue</span></code>.</p>
<p>Let’s return back to learner, learner is blocked because the dataloader cannot obtain data. Now that there is data information in <code class="docutils literal notranslate"><span class="pre">_data_result_queue</span></code>, the dataloader can take it out(here by reading from file system), process it into the format required by the learner, and hand it over to the learner <strong>to train for one iteration</strong>. After the training is completed, learner stores learn information in <code class="docutils literal notranslate"><span class="pre">_learn_info_queue</span></code>.</p>
<p>Let’s return back to comm learner’s <code class="docutils literal notranslate"><span class="pre">deal_with_learner_learn</span></code> method of comm learner. It takes out learn information from <code class="docutils literal notranslate"><span class="pre">_learn_info_queue</span></code> and returns it to coordinator through learner slave. There are <strong>two cases</strong> as for learn information:</p>
<blockquote>
<div><ul class="simple">
<li><p>Learner has not completed the training and needs more iterations: In this case, dataloader will call <code class="docutils literal notranslate"><span class="pre">get_data</span></code> again, and coordinator will continue to send task <code class="docutils literal notranslate"><span class="pre">learner_get_data_task</span></code> after receiving the information, and return to process 3.</p></li>
<li><p>Learner completes the training: Comm learner will close learner and wait for the coordinator to assign a new task <code class="docutils literal notranslate"><span class="pre">learner_start_task</span></code> again, and return to process 2.</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p>Comm learner close</p>
<blockquote>
<div><p>You can manually close the comm learner by entering a command; Otherwise, the comm learner will be <strong>resident</strong>, waiting for the coordinator to assign a new task, and return the result after execution.</p>
</div></blockquote>
</li>
</ol>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="wrapper_hook_overview.html" class="btn btn-neutral float-right" title="Wrapper &amp; Hook Overview" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="replay_buffer_overview.html" class="btn btn-neutral float-left" title="Replay Buffer Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, OpenDILab Contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>